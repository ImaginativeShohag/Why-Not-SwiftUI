//
//  Copyright Â© 2024 Md. Mahmudul Hasan Shohag. All rights reserved.
//

#if DEBUG

import Alamofire
import Moya
@testable import NetworkKit
import XCTest

final class NetworkTests: XCTestCase {
    var provider: Backend<MockAPI>!

    let certificateManagerForExampleDotCom = CertificateManager(keys: [mockPEMKeyForExampleDotCom])

    let certificateManagerForHttpBinDotOrg = CertificateManager(keys: [mockPEMKeyForHttpBinDotOrg])

    override func setUpWithError() throws {
        let domainName = URL(string: "https://example.com")!.host!
        let evaluators: [String: ServerTrustEvaluating] = [
            domainName: PublicKeysTrustEvaluator(
                keys: certificateManagerForExampleDotCom.publicKeys
            ),
        ]
        let serverTrustManager = ServerTrustManager(evaluators: evaluators)

        let session = NetworkSession.getNetworkSession(
            serverTrustManager: serverTrustManager
        )

        provider = Backend<MockAPI>(
            isStubbed: true,
            stubBehavior: .immediate,
            session: session
        ) { _, _ in }
    }

    override func tearDownWithError() throws {
        provider = nil
    }

    /// - Note: We are using this to utilize the `onError` callback.
    func setProvider(
        isStubbed: Bool = true,
        hostUrl: String = "https://example.com",
        onError: @escaping (_ route: String, _ code: Int) -> Void
    ) {
        let session = NetworkSession.getNetworkSession()

        provider = Backend<MockAPI>(
            isStubbed: isStubbed,
            stubBehavior: .immediate,
            session: session
        ) {
            onError($0, $1)
        }
    }

    // MARK: - Tests

    func testGetApiSuccessResult() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetSuccess)

        switch result {
        case .success(let response):
            XCTAssertTrue(response.isSuccess())
            XCTAssertEqual(response.getMessage(), "Request processed successfully.")

        case .failure(let error, let errorMessage, let statusCode):
            XCTFail("Request failed: (\(statusCode)): \(errorMessage) \n\n \(error)")
        }
    }

    func testGetApiFailResult() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetFail)

        switch result {
        case .success(let response):
            XCTAssertFalse(response.isSuccess())
            XCTAssertEqual(response.getMessage(), "Something went wrong. Try again.")

        case .failure(let error, let errorMessage, let statusCode):
            XCTFail("Request failed: (\(statusCode)): \(errorMessage) \n\n \(error)")
        }
    }

    func testGetApiErrorResult() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetError)

        switch result {
        case .success:
            XCTFail("Request should not succeed.")

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(statusCode, 500)
            XCTAssertEqual(errorMessage, "Request failed.")
        }
    }

    func testGetApiAuthenticationErrorResult() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetAuthenticationError)

        switch result {
        case .success(let response):
            if response.isSuccess() {
                XCTFail("Request should not succeed.")
            } else {
                XCTFail("Request not success: \(response.getMessage()).")
            }

        case .failure(_, let errorMessage, _):
            XCTAssertEqual(errorMessage, "Unauthenticated.")
        }
    }

    func testHttpStatusCodeMessageForEmptyResponseOnApiFail() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetErrorWithNoData)

        switch result {
        case .success(let response):
            if response.isSuccess() {
                XCTFail("Request should not be get succeeded.")
            } else {
                XCTFail("Request not success: \(response.getMessage()).")
            }

        case .failure(_, let errorMessage, _):
            XCTAssertEqual(errorMessage, "(500) \(HttpStatusCode.getMessage(for: 500))")
        }
    }

    func testHttpStatusCodeMessageForUnParsableResponseOnApiFail() async throws {
        let result = await provider.request(GeneralResponse.self, on: .mockGetErrorWithNoData)

        switch result {
        case .success(let response):
            if response.isSuccess() {
                XCTFail("Request should not be get succeeded.")
            } else {
                XCTFail("Request not success: \(response.getMessage())")
            }

        case .failure(_, let errorMessage, _):
            XCTAssertEqual(errorMessage, "(500) \(HttpStatusCode.getMessage(for: 500))")
        }
    }

    // No certificate provided for the requested host.
    func test_request_withNoMatchedCertificate_shouldFail() async throws {
        let domainName = URL(string: "https://httpbin.org")!.host!
        let evaluators: [String: ServerTrustEvaluating] = [
            domainName: PublicKeysTrustEvaluator(
                keys: certificateManagerForHttpBinDotOrg.publicKeys
            ),
        ]
        let serverTrustManager = ServerTrustManager(evaluators: evaluators)

        let session = NetworkSession.getNetworkSession(
            serverTrustManager: serverTrustManager
        )

        let provider = Backend<MockAPI>(
            isStubbed: false,
            session: session,
            onError: { route, code in
                print("route: \(route), code: \(code)")

                XCTAssertEqual(route, MockAPI.mockRequestCustomEndpoint("").path)
                XCTAssertEqual(code, -1)
            }
        )

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockRequestCustomEndpoint("")
        )

        switch result {
        case .success:
            XCTFail("Request should not succeeded.")

        case .failure(let error, let errorMessage, let statusCode):
            guard case MoyaError.underlying(let underlyingError, _) = error,
                  case AFError.serverTrustEvaluationFailed(reason: let reason) = underlyingError,
                  case AFError.ServerTrustFailureReason.noRequiredEvaluator = reason
            // Success
            else {
                XCTFail(error.localizedDescription)
                return
            }

            XCTAssertTrue(underlyingError.asAFError?.isServerTrustEvaluationError ?? false)
            XCTAssertEqual(errorMessage, underlyingError.localizedDescription)
            XCTAssertEqual(-1, statusCode)
        }
    }

    func test_withTaskCancelled_shouldGetError() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccess.path)
            XCTAssertEqual(code, -1)
        }

        let task = _Concurrency.Task {
            await provider.request(GeneralResponse.self, on: .mockGetSuccess)
        }

        task.cancel()

        switch await task.value {
        case .success:
            XCTFail("Task was canceled so it should not succeed.")

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(statusCode, -1)
            XCTAssertEqual(errorMessage, "Request cancelled!")
        }
    }

    func test_withSuccessResponse_withWrongModel_shouldGetMappingError() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccess.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(String.self, on: .mockGetSuccess)

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "Invalid server response. Please try again.")
            XCTAssertEqual(200, statusCode)
        }
    }

    func test_request_withErrorResponse_shouldGetStatusCodeError() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetError.path)
            XCTAssertEqual(code, 500)
        }

        let result = await provider.request(GeneralResponse.self, on: .mockGetError)

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "Request failed.")
            XCTAssertEqual(500, statusCode)
        }
    }

    func test_request_withErrorResponse_shouldGetGenericErrorMessage() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetFail.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(String.self, on: .mockGetFail)

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "Invalid server response. Please try again.")
            XCTAssertEqual(200, statusCode)
        }
    }

    func test_request_withAuthenticationError_shouldFail() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetAuthenticationError.path)
            XCTAssertEqual(code, 401)
        }

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockGetAuthenticationError
        )

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "Unauthenticated.")
            XCTAssertEqual(401, statusCode)
        }
    }

    func test_request_withSuccess_withEmptyResponse_withWrongModel_shouldFail() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccessWithEmpty.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockGetSuccessWithEmpty
        )

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "Invalid server response. Please try again.")
            XCTAssertEqual(200, statusCode)
        }
    }

    func test_request_withSuccess_withEmptyResponse_withEmptyModel_shouldSucceed() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccessWithEmpty.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(
            Empty.self,
            on: .mockGetSuccessWithEmpty
        )

        switch result {
        case .success(let response):
            XCTAssertEqual(response, Empty.value)

        case .failure:
            XCTFail()
        }
    }

    func test_request_withSuccess_withNilResponse_withEmptyModel_shouldSucceed() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccessWithNil.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(
            Empty.self,
            on: .mockGetSuccessWithNil
        )

        switch result {
        case .success(let response):
            XCTAssertEqual(response, Empty.value)

        case .failure:
            XCTFail()
        }
    }

    func test_request_withSuccess_withNoData_withEmptyModel_shouldSucceed() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetSuccessWithNoData.path)
            XCTAssertEqual(code, 200)
        }

        let result = await provider.request(
            Empty.self,
            on: .mockGetSuccessWithNoData
        )

        switch result {
        case .success(let response):
            XCTAssertEqual(response, Empty.value)

        case .failure:
            XCTFail()
        }
    }

    func test_request_withSuccess_withUnParsableData_shouldFailToParse() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetErrorWithUnParsableData.path)
            XCTAssertEqual(code, 500)
        }

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockGetErrorWithUnParsableData
        )

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "(500) Internal Server Error. Please try again.")
            XCTAssertEqual(500, statusCode)
        }
    }

    func test_request_withSuccess_withNoData_shouldFailToParse() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetErrorWithNoData.path)
            XCTAssertEqual(code, 500)
        }

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockGetErrorWithNoData
        )

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "(500) Internal Server Error. Please try again.")
            XCTAssertEqual(500, statusCode)
        }
    }

    func test_request_withError_withEmptyResponse_shouldFail() async throws {
        setProvider { route, code in
            XCTAssertEqual(route, MockAPI.mockGetErrorWithEmpty.path)
            XCTAssertEqual(code, 500)
        }

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockGetErrorWithEmpty
        )

        switch result {
        case .success:
            XCTFail()

        case .failure(_, let errorMessage, let statusCode):
            XCTAssertEqual(errorMessage, "(500) Internal Server Error. Please try again.")
            XCTAssertEqual(500, statusCode)
        }
    }

    // Provided certificate not matched with the server certificate.
    func test_request_withMismatchCertificate_shouldFail() async throws {
        let domainName = URL(string: "https://example.com")!.host!
        let evaluators: [String: ServerTrustEvaluating] = [
            domainName: PublicKeysTrustEvaluator(
                keys: certificateManagerForHttpBinDotOrg.publicKeys
            ),
        ]
        let serverTrustManager = ServerTrustManager(evaluators: evaluators)

        let session = NetworkSession.getNetworkSession(
            serverTrustManager: serverTrustManager
        )

        let provider = Backend<MockAPI>(
            isStubbed: false,
            session: session,
            onError: { route, code in
                print("route: \(route), code: \(code)")

                XCTAssertEqual(route, MockAPI.mockRequestCustomEndpoint("").path)
                XCTAssertEqual(code, -1)
            }
        )

        let result = await provider.request(
            GeneralResponse.self,
            on: .mockRequestCustomEndpoint("")
        )

        switch result {
        case .success:
            XCTFail("Request should not succeeded.")

        case .failure(let error, let errorMessage, let statusCode):
            guard case MoyaError.underlying(let underlyingError, _) = error,
                  case AFError.serverTrustEvaluationFailed(reason: let reason) = underlyingError,
                  case AFError.ServerTrustFailureReason.publicKeyPinningFailed(host: _, trust: _, pinnedKeys: _, serverKeys: _) = reason
            // Success
            else {
                XCTFail(error.localizedDescription)
                return
            }

            XCTAssertTrue(underlyingError.asAFError?.isServerTrustEvaluationError ?? false)
            XCTAssertEqual(errorMessage, underlyingError.localizedDescription)
            XCTAssertEqual(-1, statusCode)
        }
    }

    // MARK: `parseResponseErrorMessage(from:)`

    func test_parseResponseErrorMessage_withStatusCodeError_shouldGetParsedMessage() async throws {
        let error = MoyaError.statusCode(
            Response(
                statusCode: MockAPI.mockGetError.stubStatusCode,
                data: MockAPI.mockGetError.stubData ?? Data()
            )
        )

        let errorMessage = provider.public_parseResponseErrorMessage(from: error)
        XCTAssertEqual(errorMessage, "Request failed.")
    }

    func test_parseResponseErrorMessage_withParsableResponse_withStatusCodeError_shouldGetParsedMessage() async throws {
        let error = MoyaError.statusCode(
            Response(
                statusCode: 500,
                data: """
                {
                  "success": false,
                  "message": "Request failed.",
                }
                """.data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_parseResponseErrorMessage(from: error)
        XCTAssertEqual(errorMessage, "Request failed.")
    }

    func test_parseResponseErrorMessage_withEmptyObjectResponse_withStatusCodeError_shouldGetParsedMessage() async throws {
        let error = MoyaError.statusCode(
            Response(
                statusCode: 500,
                data: "{}".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_parseResponseErrorMessage(from: error)
        XCTAssertEqual(errorMessage, "Something went wrong. Try again.")
    }

    func test_parseResponseErrorMessage_withEmptyResponse_withObjectMappingError_shouldGetNil() async throws {
        let error = MoyaError.statusCode(
            Response(
                statusCode: 200,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_parseResponseErrorMessage(from: error)
        XCTAssertNil(errorMessage)
    }

    func test_parseResponseErrorMessage_withUnParsableResponse_withObjectMappingError_shouldGetNil() async throws {
        let error = MoyaError.objectMapping(
            StubError.dummy,
            Response(
                statusCode: 200,
                data: """
                <!DOCTYPE html>
                <html>
                    <head>
                    </head>
                    <body>
                    </body>
                </html>
                """.data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_parseResponseErrorMessage(from: error)
        XCTAssertNil(errorMessage)
    }

    // MARK: `getErrorMessage(for:)`

    func test_getErrorMessage_withStatusCodeError_shouldGetDefaultMessageFromFunction() async throws {
        let error = MoyaError.statusCode(
            Response(
                statusCode: 541,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_getErrorMessage(for: error)
        XCTAssertEqual(errorMessage, "Something went wrong. Please try again!")
    }

    func test_getErrorMessage_withStatusCodeError_shouldGetMessageFromStatusCodeDictionary() async throws {
        let error1 = MoyaError.statusCode(
            Response(
                statusCode: 500,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage1 = provider.public_getErrorMessage(for: error1)
        XCTAssertEqual(errorMessage1, "Internal Server Error. Please try again.")

        let error2 = MoyaError.statusCode(
            Response(
                statusCode: 401,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage2 = provider.public_getErrorMessage(for: error2)
        XCTAssertEqual(errorMessage2, "Unauthorized! Your session has expired. Please login again to continue.")

        let error3 = MoyaError.statusCode(
            Response(
                statusCode: 404,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage3 = provider.public_getErrorMessage(for: error3)
        XCTAssertEqual(errorMessage3, "Not Found! The server could not find the requested resource.")
    }

    func test_getErrorMessage_withUnderlyingAFError_shouldGetMessageFromSessionTaskError() async throws {
        let error = MoyaError.underlying(
            AFError.sessionTaskFailed(error: StubError.dummy),
            Response(
                statusCode: 202,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_getErrorMessage(for: error)
        XCTAssertEqual(errorMessage, "Dummy error.")
    }

    func test_getErrorMessage_withUnderlyingError_shouldGetMessageFromUnderlyingError() async throws {
        let error = MoyaError.underlying(
            StubError.dummy,
            Response(
                statusCode: 202,
                data: "".data(using: .utf8) ?? Data()
            )
        )

        let errorMessage = provider.public_getErrorMessage(for: error)
        XCTAssertEqual(errorMessage, "Dummy error.")
    }

    func test_getErrorMessage_withUnderlyingError_shouldGetMessageFromUnderlyingError3() async throws {
        let error = MoyaError.requestMapping("Failed to map Endpoint to a URLRequest.")

        let errorMessage = provider.public_getErrorMessage(for: error)
        XCTAssertEqual(errorMessage, "Failed to map Endpoint to a URLRequest.")
    }
}

// MARK: - Errors

enum StubError: Error {
    case dummy
}

extension StubError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case .dummy:
            return "Dummy error."
        }
    }
}

// MARK: - Constants

// DigiCert Global G2 TLS RSA SHA256 2020 CA1 (Intermediate Certificate of example.com)
let mockPEMKeyForExampleDotCom: [Int] = [0x4d, 0x49, 0x49, 0x45, 0x79, 0x44, 0x43, 0x43, 0x41, 0x37, 0x43, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x51, 0x44, 0x50, 0x57, 0x39, 0x42, 0x69, 0x74, 0x57, 0x41, 0x76, 0x52, 0x36, 0x75, 0x46, 0x41, 0x73, 0x49, 0x38, 0x7a, 0x77, 0x5a, 0x6a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x41, 0x44, 0x42, 0x68, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4a, 0x56, 0x55, 0x7a, 0x45, 0x56, 0x4d, 0x42, 0x4d, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x68, 0x4d, 0x4d, 0x52, 0x47, 0x6c, 0x6e, 0x61, 0x55, 0x4e, 0x6c, 0x63, 0x6e, 0x51, 0x67, 0x53, 0x57, 0x35, 0x6a, 0x4d, 0x52, 0x6b, 0x77, 0x46, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x45, 0x78, 0x42, 0x33, 0x64, 0x33, 0x63, 0x75, 0x5a, 0x47, 0x6c, 0x6e, 0x61, 0x57, 0x4e, 0x6c, 0x63, 0x6e, 0x51, 0x75, 0x59, 0x32, 0x39, 0x74, 0x4d, 0x53, 0x41, 0x77, 0x48, 0x67, 0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x45, 0x78, 0x64, 0x45, 0x61, 0x57, 0x64, 0x70, 0x51, 0x32, 0x56, 0x79, 0x64, 0x43, 0x42, 0x48, 0x62, 0x47, 0x39, 0x69, 0x59, 0x57, 0x77, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x43, 0x42, 0x48, 0x4d, 0x6a, 0x41, 0x65, 0x46, 0x77, 0x30, 0x79, 0x4d, 0x54, 0x41, 0x7a, 0x4d, 0x7a, 0x41, 0x77, 0x4d, 0x44, 0x41, 0x77, 0x4d, 0x44, 0x42, 0x61, 0x46, 0x77, 0x30, 0x7a, 0x4d, 0x54, 0x41, 0x7a, 0x4d, 0x6a, 0x6b, 0x79, 0x4d, 0x7a, 0x55, 0x35, 0x4e, 0x54, 0x6c, 0x61, 0x4d, 0x46, 0x6b, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6c, 0x56, 0x54, 0x4d, 0x52, 0x55, 0x77, 0x45, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4b, 0x45, 0x77, 0x78, 0x45, 0x61, 0x57, 0x64, 0x70, 0x51, 0x32, 0x56, 0x79, 0x64, 0x43, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x78, 0x4d, 0x7a, 0x41, 0x78, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x54, 0x4b, 0x6b, 0x52, 0x70, 0x5a, 0x32, 0x6c, 0x44, 0x5a, 0x58, 0x4a, 0x30, 0x49, 0x45, 0x64, 0x73, 0x62, 0x32, 0x4a, 0x68, 0x62, 0x43, 0x42, 0x48, 0x4d, 0x69, 0x42, 0x55, 0x54, 0x46, 0x4d, 0x67, 0x55, 0x6c, 0x4e, 0x42, 0x49, 0x46, 0x4e, 0x49, 0x51, 0x54, 0x49, 0x31, 0x4e, 0x69, 0x41, 0x79, 0x4d, 0x44, 0x49, 0x77, 0x49, 0x45, 0x4e, 0x42, 0x4d, 0x54, 0x43, 0x43, 0x41, 0x53, 0x49, 0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x67, 0x45, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x51, 0x6f, 0x43, 0x67, 0x67, 0x45, 0x42, 0x41, 0x4d, 0x7a, 0x33, 0x45, 0x47, 0x4a, 0x50, 0x70, 0x72, 0x74, 0x6a, 0x62, 0x2b, 0x32, 0x51, 0x55, 0x6c, 0x62, 0x46, 0x62, 0x53, 0x64, 0x37, 0x65, 0x68, 0x4a, 0x57, 0x69, 0x76, 0x48, 0x30, 0x2b, 0x64, 0x62, 0x6e, 0x34, 0x59, 0x2b, 0x39, 0x6c, 0x61, 0x76, 0x79, 0x59, 0x45, 0x45, 0x56, 0x63, 0x4e, 0x73, 0x53, 0x41, 0x50, 0x6f, 0x6e, 0x43, 0x72, 0x56, 0x58, 0x4f, 0x46, 0x74, 0x39, 0x73, 0x6c, 0x47, 0x54, 0x63, 0x5a, 0x55, 0x4f, 0x61, 0x6b, 0x47, 0x55, 0x57, 0x7a, 0x55, 0x62, 0x2b, 0x6e, 0x76, 0x36, 0x75, 0x38, 0x57, 0x2b, 0x4a, 0x44, 0x44, 0x2b, 0x56, 0x75, 0x2f, 0x45, 0x38, 0x33, 0x32, 0x58, 0x34, 0x78, 0x54, 0x31, 0x46, 0x45, 0x33, 0x4c, 0x70, 0x78, 0x44, 0x79, 0x46, 0x75, 0x71, 0x72, 0x49, 0x76, 0x41, 0x78, 0x49, 0x68, 0x46, 0x68, 0x61, 0x5a, 0x41, 0x6d, 0x75, 0x6e, 0x6a, 0x5a, 0x6c, 0x78, 0x2f, 0x6a, 0x66, 0x57, 0x61, 0x72, 0x64, 0x55, 0x53, 0x56, 0x63, 0x38, 0x69, 0x73, 0x2f, 0x2b, 0x39, 0x64, 0x43, 0x6f, 0x70, 0x5a, 0x51, 0x2b, 0x47, 0x73, 0x73, 0x6a, 0x6f, 0x50, 0x38, 0x30, 0x6a, 0x38, 0x31, 0x32, 0x73, 0x33, 0x77, 0x57, 0x50, 0x63, 0x33, 0x6b, 0x62, 0x57, 0x32, 0x30, 0x58, 0x2b, 0x66, 0x53, 0x50, 0x39, 0x6b, 0x4f, 0x68, 0x52, 0x42, 0x78, 0x35, 0x52, 0x6f, 0x31, 0x2f, 0x74, 0x53, 0x55, 0x5a, 0x55, 0x66, 0x79, 0x79, 0x49, 0x78, 0x66, 0x51, 0x54, 0x6e, 0x4a, 0x63, 0x56, 0x50, 0x41, 0x50, 0x6f, 0x6f, 0x54, 0x6e, 0x63, 0x61, 0x51, 0x77, 0x79, 0x77, 0x61, 0x38, 0x57, 0x56, 0x30, 0x79, 0x55, 0x52, 0x30, 0x4a, 0x38, 0x6f, 0x73, 0x69, 0x63, 0x66, 0x65, 0x62, 0x55, 0x54, 0x56, 0x53, 0x76, 0x51, 0x70, 0x6d, 0x6f, 0x77, 0x51, 0x54, 0x43, 0x64, 0x35, 0x7a, 0x57, 0x53, 0x4f, 0x54, 0x4f, 0x45, 0x65, 0x41, 0x71, 0x67, 0x4a, 0x6e, 0x77, 0x51, 0x33, 0x44, 0x50, 0x50, 0x33, 0x5a, 0x72, 0x30, 0x55, 0x78, 0x4a, 0x71, 0x79, 0x52, 0x65, 0x77, 0x67, 0x32, 0x43, 0x2f, 0x55, 0x61, 0x6f, 0x71, 0x32, 0x79, 0x54, 0x7a, 0x47, 0x4a, 0x53, 0x51, 0x6e, 0x57, 0x53, 0x2b, 0x4a, 0x72, 0x36, 0x58, 0x6c, 0x36, 0x79, 0x73, 0x47, 0x48, 0x6c, 0x48, 0x78, 0x2b, 0x35, 0x66, 0x77, 0x6d, 0x59, 0x36, 0x44, 0x33, 0x36, 0x67, 0x33, 0x39, 0x48, 0x61, 0x61, 0x45, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4f, 0x43, 0x41, 0x59, 0x49, 0x77, 0x67, 0x67, 0x46, 0x2b, 0x4d, 0x42, 0x49, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45, 0x77, 0x45, 0x42, 0x2f, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4f, 0x42, 0x42, 0x59, 0x45, 0x46, 0x48, 0x53, 0x46, 0x67, 0x4d, 0x42, 0x6d, 0x78, 0x39, 0x38, 0x33, 0x33, 0x73, 0x2b, 0x39, 0x4b, 0x54, 0x65, 0x71, 0x41, 0x78, 0x32, 0x2b, 0x37, 0x63, 0x30, 0x58, 0x4d, 0x42, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4d, 0x42, 0x61, 0x41, 0x46, 0x45, 0x34, 0x69, 0x56, 0x43, 0x41, 0x59, 0x6c, 0x65, 0x62, 0x6a, 0x62, 0x75, 0x59, 0x50, 0x2b, 0x76, 0x71, 0x35, 0x45, 0x75, 0x30, 0x47, 0x46, 0x34, 0x38, 0x35, 0x4d, 0x41, 0x34, 0x47, 0x41, 0x31, 0x55, 0x64, 0x44, 0x77, 0x45, 0x42, 0x2f, 0x77, 0x51, 0x45, 0x41, 0x77, 0x49, 0x42, 0x68, 0x6a, 0x41, 0x64, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x53, 0x55, 0x45, 0x46, 0x6a, 0x41, 0x55, 0x42, 0x67, 0x67, 0x72, 0x42, 0x67, 0x45, 0x46, 0x42, 0x51, 0x63, 0x44, 0x41, 0x51, 0x59, 0x49, 0x4b, 0x77, 0x59, 0x42, 0x42, 0x51, 0x55, 0x48, 0x41, 0x77, 0x49, 0x77, 0x64, 0x67, 0x59, 0x49, 0x4b, 0x77, 0x59, 0x42, 0x42, 0x51, 0x55, 0x48, 0x41, 0x51, 0x45, 0x45, 0x61, 0x6a, 0x42, 0x6f, 0x4d, 0x43, 0x51, 0x47, 0x43, 0x43, 0x73, 0x47, 0x41, 0x51, 0x55, 0x46, 0x42, 0x7a, 0x41, 0x42, 0x68, 0x68, 0x68, 0x6f, 0x64, 0x48, 0x52, 0x77, 0x4f, 0x69, 0x38, 0x76, 0x62, 0x32, 0x4e, 0x7a, 0x63, 0x43, 0x35, 0x6b, 0x61, 0x57, 0x64, 0x70, 0x59, 0x32, 0x56, 0x79, 0x64, 0x43, 0x35, 0x6a, 0x62, 0x32, 0x30, 0x77, 0x51, 0x41, 0x59, 0x49, 0x4b, 0x77, 0x59, 0x42, 0x42, 0x51, 0x55, 0x48, 0x4d, 0x41, 0x4b, 0x47, 0x4e, 0x47, 0x68, 0x30, 0x64, 0x48, 0x41, 0x36, 0x4c, 0x79, 0x39, 0x6a, 0x59, 0x57, 0x4e, 0x6c, 0x63, 0x6e, 0x52, 0x7a, 0x4c, 0x6d, 0x52, 0x70, 0x5a, 0x32, 0x6c, 0x6a, 0x5a, 0x58, 0x4a, 0x30, 0x4c, 0x6d, 0x4e, 0x76, 0x62, 0x53, 0x39, 0x45, 0x61, 0x57, 0x64, 0x70, 0x51, 0x32, 0x56, 0x79, 0x64, 0x45, 0x64, 0x73, 0x62, 0x32, 0x4a, 0x68, 0x62, 0x46, 0x4a, 0x76, 0x62, 0x33, 0x52, 0x48, 0x4d, 0x69, 0x35, 0x6a, 0x63, 0x6e, 0x51, 0x77, 0x51, 0x67, 0x59, 0x44, 0x56, 0x52, 0x30, 0x66, 0x42, 0x44, 0x73, 0x77, 0x4f, 0x54, 0x41, 0x33, 0x6f, 0x44, 0x57, 0x67, 0x4d, 0x34, 0x59, 0x78, 0x61, 0x48, 0x52, 0x30, 0x63, 0x44, 0x6f, 0x76, 0x4c, 0x32, 0x4e, 0x79, 0x62, 0x44, 0x4d, 0x75, 0x5a, 0x47, 0x6c, 0x6e, 0x61, 0x57, 0x4e, 0x6c, 0x63, 0x6e, 0x51, 0x75, 0x59, 0x32, 0x39, 0x74, 0x4c, 0x30, 0x52, 0x70, 0x5a, 0x32, 0x6c, 0x44, 0x5a, 0x58, 0x4a, 0x30, 0x52, 0x32, 0x78, 0x76, 0x59, 0x6d, 0x46, 0x73, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x45, 0x63, 0x79, 0x4c, 0x6d, 0x4e, 0x79, 0x62, 0x44, 0x41, 0x39, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x53, 0x41, 0x45, 0x4e, 0x6a, 0x41, 0x30, 0x4d, 0x41, 0x73, 0x47, 0x43, 0x57, 0x43, 0x47, 0x53, 0x41, 0x47, 0x47, 0x2f, 0x57, 0x77, 0x43, 0x41, 0x54, 0x41, 0x48, 0x42, 0x67, 0x56, 0x6e, 0x67, 0x51, 0x77, 0x42, 0x41, 0x54, 0x41, 0x49, 0x42, 0x67, 0x5a, 0x6e, 0x67, 0x51, 0x77, 0x42, 0x41, 0x67, 0x45, 0x77, 0x43, 0x41, 0x59, 0x47, 0x5a, 0x34, 0x45, 0x4d, 0x41, 0x51, 0x49, 0x43, 0x4d, 0x41, 0x67, 0x47, 0x42, 0x6d, 0x65, 0x42, 0x44, 0x41, 0x45, 0x43, 0x41, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x45, 0x41, 0x6b, 0x50, 0x46, 0x77, 0x79, 0x79, 0x69, 0x58, 0x61, 0x5a, 0x64, 0x38, 0x64, 0x50, 0x33, 0x41, 0x2b, 0x69, 0x5a, 0x37, 0x55, 0x36, 0x75, 0x74, 0x7a, 0x57, 0x58, 0x39, 0x75, 0x70, 0x77, 0x47, 0x6e, 0x49, 0x72, 0x58, 0x57, 0x6b, 0x4f, 0x48, 0x37, 0x55, 0x31, 0x4d, 0x56, 0x6c, 0x2b, 0x74, 0x77, 0x63, 0x57, 0x31, 0x42, 0x53, 0x41, 0x75, 0x57, 0x64, 0x48, 0x2f, 0x53, 0x76, 0x57, 0x67, 0x4b, 0x74, 0x69, 0x77, 0x6c, 0x61, 0x33, 0x4a, 0x4c, 0x6b, 0x6f, 0x37, 0x31, 0x36, 0x66, 0x32, 0x62, 0x34, 0x67, 0x70, 0x2f, 0x44, 0x41, 0x2f, 0x4a, 0x49, 0x53, 0x37, 0x77, 0x37, 0x64, 0x37, 0x6b, 0x77, 0x63, 0x73, 0x72, 0x34, 0x64, 0x72, 0x64, 0x6a, 0x50, 0x74, 0x41, 0x46, 0x56, 0x53, 0x73, 0x6c, 0x6d, 0x65, 0x35, 0x4c, 0x6e, 0x51, 0x38, 0x39, 0x2f, 0x6e, 0x44, 0x2f, 0x37, 0x64, 0x2b, 0x4d, 0x53, 0x35, 0x45, 0x48, 0x4b, 0x42, 0x43, 0x51, 0x52, 0x66, 0x7a, 0x35, 0x65, 0x65, 0x4c, 0x6a, 0x4a, 0x31, 0x6a, 0x73, 0x2b, 0x61, 0x57, 0x4e, 0x4a, 0x58, 0x4d, 0x58, 0x34, 0x33, 0x41, 0x59, 0x47, 0x79, 0x5a, 0x6d, 0x30, 0x70, 0x47, 0x72, 0x46, 0x6d, 0x43, 0x57, 0x33, 0x52, 0x62, 0x70, 0x44, 0x30, 0x75, 0x66, 0x6f, 0x76, 0x41, 0x52, 0x54, 0x46, 0x58, 0x46, 0x5a, 0x6b, 0x41, 0x64, 0x6c, 0x39, 0x68, 0x36, 0x67, 0x34, 0x55, 0x35, 0x2b, 0x4c, 0x58, 0x55, 0x5a, 0x74, 0x58, 0x4d, 0x59, 0x6e, 0x68, 0x49, 0x48, 0x55, 0x66, 0x6f, 0x79, 0x4d, 0x6f, 0x35, 0x74, 0x53, 0x35, 0x38, 0x61, 0x49, 0x37, 0x44, 0x64, 0x38, 0x4b, 0x76, 0x76, 0x77, 0x56, 0x56, 0x6f, 0x34, 0x63, 0x68, 0x44, 0x59, 0x41, 0x42, 0x50, 0x50, 0x54, 0x48, 0x50, 0x62, 0x71, 0x6a, 0x63, 0x31, 0x71, 0x43, 0x6d, 0x42, 0x61, 0x5a, 0x78, 0x32, 0x76, 0x4e, 0x34, 0x59, 0x65, 0x35, 0x44, 0x55, 0x79, 0x73, 0x2f, 0x76, 0x5a, 0x77, 0x50, 0x39, 0x42, 0x46, 0x6f, 0x68, 0x46, 0x72, 0x48, 0x2f, 0x36, 0x6a, 0x2f, 0x66, 0x33, 0x49, 0x4c, 0x31, 0x36, 0x2f, 0x52, 0x5a, 0x6b, 0x69, 0x4d, 0x4e, 0x4a, 0x43, 0x71, 0x56, 0x4a, 0x55, 0x7a, 0x4b, 0x6f, 0x5a, 0x48, 0x6d, 0x31, 0x4c, 0x65, 0x73, 0x68, 0x33, 0x53, 0x7a, 0x38, 0x57, 0x32, 0x6a, 0x6d, 0x64, 0x76, 0x35, 0x31, 0x62, 0x32, 0x45, 0x51, 0x4a, 0x38, 0x48, 0x6d, 0x41, 0x3d, 0x3d]

// Amazon RSA 2048 M02 (Intermediate Certificate of httpbin.org)
let mockPEMKeyForHttpBinDotOrg: [Int] = [0x4d, 0x49, 0x49, 0x45, 0x58, 0x6a, 0x43, 0x43, 0x41, 0x30, 0x61, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x54, 0x42, 0x33, 0x4d, 0x53, 0x53, 0x6b, 0x76, 0x4c, 0x31, 0x45, 0x37, 0x48, 0x74, 0x54, 0x76, 0x71, 0x38, 0x5a, 0x53, 0x45, 0x4c, 0x54, 0x6f, 0x50, 0x6f, 0x54, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x41, 0x44, 0x41, 0x35, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4a, 0x56, 0x55, 0x7a, 0x45, 0x50, 0x4d, 0x41, 0x30, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x68, 0x4d, 0x47, 0x51, 0x57, 0x31, 0x68, 0x65, 0x6d, 0x39, 0x75, 0x4d, 0x52, 0x6b, 0x77, 0x46, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x45, 0x78, 0x42, 0x42, 0x62, 0x57, 0x46, 0x36, 0x62, 0x32, 0x34, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x43, 0x42, 0x44, 0x51, 0x53, 0x41, 0x78, 0x4d, 0x42, 0x34, 0x58, 0x44, 0x54, 0x49, 0x79, 0x4d, 0x44, 0x67, 0x79, 0x4d, 0x7a, 0x49, 0x79, 0x4d, 0x6a, 0x55, 0x7a, 0x4d, 0x46, 0x6f, 0x58, 0x44, 0x54, 0x4d, 0x77, 0x4d, 0x44, 0x67, 0x79, 0x4d, 0x7a, 0x49, 0x79, 0x4d, 0x6a, 0x55, 0x7a, 0x4d, 0x46, 0x6f, 0x77, 0x50, 0x44, 0x45, 0x4c, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x45, 0x42, 0x68, 0x4d, 0x43, 0x56, 0x56, 0x4d, 0x78, 0x44, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x6f, 0x54, 0x42, 0x6b, 0x46, 0x74, 0x59, 0x58, 0x70, 0x76, 0x62, 0x6a, 0x45, 0x63, 0x4d, 0x42, 0x6f, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x78, 0x4d, 0x54, 0x51, 0x57, 0x31, 0x68, 0x65, 0x6d, 0x39, 0x75, 0x49, 0x46, 0x4a, 0x54, 0x51, 0x53, 0x41, 0x79, 0x4d, 0x44, 0x51, 0x34, 0x49, 0x45, 0x30, 0x77, 0x4d, 0x6a, 0x43, 0x43, 0x41, 0x53, 0x49, 0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x67, 0x45, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x51, 0x6f, 0x43, 0x67, 0x67, 0x45, 0x42, 0x41, 0x4c, 0x74, 0x44, 0x47, 0x4d, 0x5a, 0x61, 0x71, 0x48, 0x6e, 0x65, 0x4b, 0x65, 0x69, 0x31, 0x62, 0x79, 0x36, 0x2b, 0x70, 0x55, 0x50, 0x50, 0x4c, 0x6c, 0x6a, 0x54, 0x42, 0x31, 0x34, 0x33, 0x53, 0x69, 0x36, 0x56, 0x70, 0x45, 0x57, 0x50, 0x63, 0x36, 0x6d, 0x53, 0x6b, 0x46, 0x68, 0x5a, 0x62, 0x2f, 0x36, 0x71, 0x72, 0x6b, 0x5a, 0x79, 0x6f, 0x48, 0x6c, 0x51, 0x4c, 0x62, 0x44, 0x59, 0x6e, 0x49, 0x32, 0x44, 0x37, 0x68, 0x44, 0x30, 0x73, 0x64, 0x7a, 0x45, 0x71, 0x66, 0x6e, 0x75, 0x41, 0x6a, 0x49, 0x73, 0x75, 0x58, 0x51, 0x4c, 0x47, 0x33, 0x41, 0x38, 0x54, 0x76, 0x58, 0x36, 0x56, 0x33, 0x6f, 0x46, 0x4e, 0x42, 0x46, 0x56, 0x65, 0x38, 0x4e, 0x6c, 0x4c, 0x4a, 0x48, 0x76, 0x42, 0x73, 0x65, 0x4b, 0x59, 0x38, 0x38, 0x73, 0x61, 0x4c, 0x77, 0x75, 0x66, 0x78, 0x6b, 0x5a, 0x56, 0x77, 0x6b, 0x37, 0x34, 0x67, 0x34, 0x6e, 0x57, 0x6c, 0x4e, 0x4d, 0x58, 0x7a, 0x6c, 0x61, 0x39, 0x59, 0x35, 0x46, 0x33, 0x77, 0x77, 0x52, 0x48, 0x77, 0x4d, 0x56, 0x48, 0x34, 0x34, 0x33, 0x78, 0x47, 0x7a, 0x36, 0x55, 0x74, 0x47, 0x53, 0x5a, 0x53, 0x71, 0x51, 0x39, 0x34, 0x65, 0x46, 0x78, 0x35, 0x58, 0x37, 0x54, 0x6c, 0x71, 0x74, 0x38, 0x77, 0x68, 0x69, 0x38, 0x71, 0x43, 0x61, 0x4b, 0x64, 0x5a, 0x35, 0x72, 0x4e, 0x61, 0x6b, 0x2b, 0x72, 0x39, 0x6e, 0x55, 0x54, 0x68, 0x4f, 0x65, 0x43, 0x6c, 0x71, 0x46, 0x64, 0x34, 0x6f, 0x58, 0x79, 0x63, 0x68, 0x2f, 0x2f, 0x52, 0x63, 0x37, 0x59, 0x30, 0x65, 0x58, 0x31, 0x4b, 0x4e, 0x57, 0x48, 0x59, 0x53, 0x49, 0x31, 0x4e, 0x6b, 0x33, 0x31, 0x6d, 0x59, 0x67, 0x69, 0x4b, 0x33, 0x4a, 0x76, 0x48, 0x30, 0x36, 0x33, 0x67, 0x2b, 0x4b, 0x39, 0x74, 0x48, 0x41, 0x36, 0x33, 0x5a, 0x65, 0x54, 0x67, 0x4b, 0x67, 0x6e, 0x64, 0x6c, 0x68, 0x2b, 0x57, 0x49, 0x2b, 0x7a, 0x76, 0x37, 0x69, 0x34, 0x34, 0x48, 0x65, 0x70, 0x52, 0x5a, 0x6a, 0x41, 0x31, 0x46, 0x59, 0x77, 0x59, 0x5a, 0x39, 0x56, 0x76, 0x2f, 0x39, 0x55, 0x6b, 0x43, 0x35, 0x59, 0x7a, 0x38, 0x2f, 0x79, 0x55, 0x36, 0x35, 0x66, 0x67, 0x6a, 0x61, 0x45, 0x2b, 0x77, 0x56, 0x48, 0x4d, 0x34, 0x65, 0x2f, 0x59, 0x79, 0x43, 0x32, 0x6f, 0x73, 0x72, 0x50, 0x57, 0x45, 0x37, 0x67, 0x4a, 0x2b, 0x64, 0x58, 0x4d, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4f, 0x43, 0x41, 0x56, 0x6f, 0x77, 0x67, 0x67, 0x46, 0x57, 0x4d, 0x42, 0x49, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45, 0x77, 0x45, 0x42, 0x2f, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41, 0x77, 0x44, 0x67, 0x59, 0x44, 0x56, 0x52, 0x30, 0x50, 0x41, 0x51, 0x48, 0x2f, 0x42, 0x41, 0x51, 0x44, 0x41, 0x67, 0x47, 0x47, 0x4d, 0x42, 0x30, 0x47, 0x41, 0x31, 0x55, 0x64, 0x4a, 0x51, 0x51, 0x57, 0x4d, 0x42, 0x51, 0x47, 0x43, 0x43, 0x73, 0x47, 0x41, 0x51, 0x55, 0x46, 0x42, 0x77, 0x4d, 0x42, 0x42, 0x67, 0x67, 0x72, 0x42, 0x67, 0x45, 0x46, 0x42, 0x51, 0x63, 0x44, 0x41, 0x6a, 0x41, 0x64, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x51, 0x34, 0x45, 0x46, 0x67, 0x51, 0x55, 0x77, 0x44, 0x46, 0x53, 0x7a, 0x56, 0x70, 0x51, 0x77, 0x34, 0x4a, 0x38, 0x64, 0x48, 0x48, 0x4f, 0x79, 0x2b, 0x6d, 0x63, 0x2b, 0x58, 0x72, 0x72, 0x67, 0x75, 0x49, 0x77, 0x48, 0x77, 0x59, 0x44, 0x56, 0x52, 0x30, 0x6a, 0x42, 0x42, 0x67, 0x77, 0x46, 0x6f, 0x41, 0x55, 0x68, 0x42, 0x6a, 0x4d, 0x68, 0x54, 0x54, 0x73, 0x76, 0x41, 0x79, 0x55, 0x6c, 0x43, 0x34, 0x49, 0x57, 0x5a, 0x7a, 0x48, 0x73, 0x68, 0x42, 0x4f, 0x43, 0x67, 0x67, 0x77, 0x65, 0x77, 0x59, 0x49, 0x4b, 0x77, 0x59, 0x42, 0x42, 0x51, 0x55, 0x48, 0x41, 0x51, 0x45, 0x45, 0x62, 0x7a, 0x42, 0x74, 0x4d, 0x43, 0x38, 0x47, 0x43, 0x43, 0x73, 0x47, 0x41, 0x51, 0x55, 0x46, 0x42, 0x7a, 0x41, 0x42, 0x68, 0x69, 0x4e, 0x6f, 0x64, 0x48, 0x52, 0x77, 0x4f, 0x69, 0x38, 0x76, 0x62, 0x32, 0x4e, 0x7a, 0x63, 0x43, 0x35, 0x79, 0x62, 0x32, 0x39, 0x30, 0x59, 0x32, 0x45, 0x78, 0x4c, 0x6d, 0x46, 0x74, 0x59, 0x58, 0x70, 0x76, 0x62, 0x6e, 0x52, 0x79, 0x64, 0x58, 0x4e, 0x30, 0x4c, 0x6d, 0x4e, 0x76, 0x62, 0x54, 0x41, 0x36, 0x42, 0x67, 0x67, 0x72, 0x42, 0x67, 0x45, 0x46, 0x42, 0x51, 0x63, 0x77, 0x41, 0x6f, 0x59, 0x75, 0x61, 0x48, 0x52, 0x30, 0x63, 0x44, 0x6f, 0x76, 0x4c, 0x32, 0x4e, 0x79, 0x64, 0x43, 0x35, 0x79, 0x62, 0x32, 0x39, 0x30, 0x59, 0x32, 0x45, 0x78, 0x4c, 0x6d, 0x46, 0x74, 0x59, 0x58, 0x70, 0x76, 0x62, 0x6e, 0x52, 0x79, 0x64, 0x58, 0x4e, 0x30, 0x4c, 0x6d, 0x4e, 0x76, 0x62, 0x53, 0x39, 0x79, 0x62, 0x32, 0x39, 0x30, 0x59, 0x32, 0x45, 0x78, 0x4c, 0x6d, 0x4e, 0x6c, 0x63, 0x6a, 0x41, 0x2f, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x52, 0x38, 0x45, 0x4f, 0x44, 0x41, 0x32, 0x4d, 0x44, 0x53, 0x67, 0x4d, 0x71, 0x41, 0x77, 0x68, 0x69, 0x35, 0x6f, 0x64, 0x48, 0x52, 0x77, 0x4f, 0x69, 0x38, 0x76, 0x59, 0x33, 0x4a, 0x73, 0x4c, 0x6e, 0x4a, 0x76, 0x62, 0x33, 0x52, 0x6a, 0x59, 0x54, 0x45, 0x75, 0x59, 0x57, 0x31, 0x68, 0x65, 0x6d, 0x39, 0x75, 0x64, 0x48, 0x4a, 0x31, 0x63, 0x33, 0x51, 0x75, 0x59, 0x32, 0x39, 0x74, 0x4c, 0x33, 0x4a, 0x76, 0x62, 0x33, 0x52, 0x6a, 0x59, 0x54, 0x45, 0x75, 0x59, 0x33, 0x4a, 0x73, 0x4d, 0x42, 0x4d, 0x47, 0x41, 0x31, 0x55, 0x64, 0x49, 0x41, 0x51, 0x4d, 0x4d, 0x41, 0x6f, 0x77, 0x43, 0x41, 0x59, 0x47, 0x5a, 0x34, 0x45, 0x4d, 0x41, 0x51, 0x49, 0x42, 0x4d, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x43, 0x77, 0x55, 0x41, 0x41, 0x34, 0x49, 0x42, 0x41, 0x51, 0x41, 0x74, 0x54, 0x69, 0x36, 0x46, 0x73, 0x30, 0x41, 0x7a, 0x66, 0x69, 0x2b, 0x69, 0x77, 0x6d, 0x37, 0x6a, 0x72, 0x7a, 0x2b, 0x43, 0x53, 0x78, 0x48, 0x48, 0x2b, 0x75, 0x48, 0x6c, 0x37, 0x4c, 0x61, 0x77, 0x33, 0x4d, 0x51, 0x53, 0x58, 0x56, 0x74, 0x52, 0x38, 0x52, 0x56, 0x35, 0x33, 0x50, 0x74, 0x52, 0x36, 0x72, 0x2f, 0x36, 0x67, 0x4e, 0x70, 0x71, 0x6c, 0x7a, 0x64, 0x6f, 0x5a, 0x71, 0x34, 0x46, 0x4b, 0x62, 0x41, 0x44, 0x69, 0x31, 0x76, 0x39, 0x42, 0x75, 0x6e, 0x38, 0x52, 0x59, 0x38, 0x44, 0x35, 0x31, 0x75, 0x65, 0x64, 0x52, 0x66, 0x6a, 0x73, 0x62, 0x65, 0x6f, 0x64, 0x69, 0x7a, 0x65, 0x42, 0x42, 0x38, 0x6e, 0x58, 0x6d, 0x65, 0x79, 0x44, 0x33, 0x33, 0x45, 0x70, 0x37, 0x56, 0x41, 0x54, 0x6a, 0x34, 0x6f, 0x7a, 0x63, 0x64, 0x33, 0x31, 0x59, 0x46, 0x56, 0x66, 0x67, 0x52, 0x68, 0x76, 0x54, 0x53, 0x78, 0x4e, 0x72, 0x72, 0x54, 0x6c, 0x4e, 0x70, 0x57, 0x6b, 0x55, 0x6b, 0x30, 0x6d, 0x33, 0x42, 0x4d, 0x50, 0x76, 0x38, 0x73, 0x67, 0x33, 0x38, 0x31, 0x48, 0x68, 0x41, 0x36, 0x75, 0x45, 0x59, 0x6f, 0x6b, 0x45, 0x35, 0x71, 0x39, 0x75, 0x77, 0x73, 0x2f, 0x33, 0x59, 0x6b, 0x4b, 0x71, 0x52, 0x69, 0x45, 0x7a, 0x33, 0x54, 0x73, 0x61, 0x57, 0x6d, 0x4a, 0x71, 0x49, 0x52, 0x5a, 0x68, 0x4d, 0x62, 0x67, 0x41, 0x66, 0x70, 0x37, 0x4f, 0x37, 0x46, 0x55, 0x77, 0x46, 0x49, 0x62, 0x37, 0x55, 0x49, 0x73, 0x70, 0x6f, 0x67, 0x5a, 0x53, 0x4b, 0x78, 0x50, 0x49, 0x57, 0x4a, 0x70, 0x78, 0x69, 0x50, 0x6f, 0x33, 0x54, 0x63, 0x42, 0x61, 0x6d, 0x62, 0x62, 0x56, 0x74, 0x51, 0x4f, 0x63, 0x4e, 0x52, 0x57, 0x7a, 0x35, 0x71, 0x43, 0x51, 0x64, 0x44, 0x73, 0x6c, 0x49, 0x32, 0x79, 0x61, 0x79, 0x71, 0x30, 0x6e, 0x32, 0x54, 0x58, 0x6f, 0x48, 0x79, 0x4e, 0x43, 0x4c, 0x45, 0x48, 0x38, 0x72, 0x70, 0x73, 0x4a, 0x52, 0x56, 0x49, 0x4c, 0x46, 0x73, 0x67, 0x30, 0x6a, 0x63, 0x37, 0x42, 0x61, 0x46, 0x72, 0x4d, 0x6e, 0x46, 0x34, 0x36, 0x32, 0x2b, 0x61, 0x6a, 0x53, 0x65, 0x68, 0x67, 0x6a, 0x31, 0x32, 0x49, 0x69, 0x64, 0x4e, 0x65, 0x52, 0x4e, 0x34, 0x7a, 0x6c, 0x2b, 0x45, 0x6f, 0x4e, 0x61, 0x57, 0x64, 0x70, 0x6e, 0x57, 0x6e, 0x64, 0x76, 0x53, 0x70, 0x41, 0x45, 0x6b, 0x71, 0x32, 0x50]

#endif
